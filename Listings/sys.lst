C51 COMPILER V9.60.7.0   SYS                                                               11/06/2023 23:38:38 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE SYS
OBJECT MODULE PLACED IN .\Objects\sys.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\lib\SRC\sys.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\src\lib\INC) D
                    -EBUG OBJECTEXTEND PRINT(.\Listings\sys.lst) OBJECT(.\Objects\sys.obj)

line level    source

   1          #include "sys.h"
   2          
   3          u32 data _systick_ccr = 0;
   4          
   5          #ifdef DEV_PLATFROM
   6          
   7          bit busy = 0;
   8          /**
   9           * 关键字code是51单片机特有关键字
  10           * 而运用code关键字修饰下定义的变量，比如unsigned char code i；
  11           * 它们则存储在单片机程序存储空间FLASH中，节省单片机RAM资源，但在程序中不能更改这些变量的值。
  12           */
  13          char* code STCISPCMD = "@STCISP#";
  14          u8 rx_index = 0;
  15          
  16          void hal_init_uart(void) {
  17   1          SCON = 0x50;   // 8位数据,可变波特率
  18   1          AUXR |= 0x40;  // 定时器时钟1T模式
  19   1          AUXR &= 0xFE;  // 串口1选择定时器1为波特率发生器
  20   1          TMOD &= 0x0F;  // 设置定时器模式
  21   1          TL1 = 0xD0;    // 设置定时初始值
  22   1          TH1 = 0xFF;    // 设置定时初始值
  23   1          ET1 = 0;       // 禁止定时器中断
  24   1          TR1 = 1;       // 定时器1开始计时
  25   1          ES = 1;        // 使能串口1中断
  26   1      }
  27          void hal_uart_isr() interrupt 4 {
  28   1          char dat;
  29   1          if (TI) {
  30   2              TI = 0;
  31   2              busy = 0;
  32   2          }
  33   1          if (RI) {
  34   2              RI = 0;
  35   2              dat = SBUF;
  36   2              if (dat == STCISPCMD[rx_index]) {
  37   3                  rx_index++;
  38   3                  if (STCISPCMD[rx_index] == '\0') {
  39   4                      IAP_CONTR = 0x60;  // 软复位到ISP进行下载
  40   4                  }
  41   3              } else {
  42   3                  // 不匹配重新开始
  43   3                  rx_index++;
  44   3                  if (dat == STCISPCMD[rx_index]) {
  45   4                      rx_index++;
  46   4                  }
  47   3              }
  48   2          }
  49   1      }
  50          
  51          void hal_uart_send(char* str) {
  52   1          while (*str) {
  53   2              while (busy)
  54   2                  ;
C51 COMPILER V9.60.7.0   SYS                                                               11/06/2023 23:38:38 PAGE 2   

  55   2              busy = 1;
  56   2              SBUF = *str;
  57   2              str++;
  58   2          }
  59   1      }
  60          
  61          char putchar(char ch) {
  62   1          while (busy)
  63   1              ;
  64   1          busy = 1;
  65   1          SBUF = ch;
  66   1          return ch;
  67   1      }
  68          #else
              void hal_init_uart(void) {}
              void hal_uart_send(char* str) {}
              #endif
  72          
  73          void hal_init_systick() {
  74   1          // 1毫秒@22.1184MHz
  75   1          AUXR |= 0x80;  // 定时器时钟1T模式
  76   1          TMOD = 0xF3;   // 设置定时器模式
  77   1          TL0 = 0x9A;    // 设置定时初始值
  78   1          TH0 = 0xA9;    // 设置定时初始值
  79   1          TF0 = 0;       // 清除TF0标志
  80   1          TR0 = 1;       // 定时器0开始计时
  81   1          ET0 = 1;       // 使能定时器0中断
  82   1      }
  83          
  84          u32 hal_systick_get() {
  85   1          return _systick_ccr;
  86   1      }
  87          
  88          void timer0_Isr(void) interrupt 1 {
  89   1          _systick_ccr++;
  90   1          TF0 = 0;  // 清除TF0标志
  91   1      }
  92          
  93          void hal_init_all_gpio(void) {
  94   1          P3M0 = 0x00;
  95   1          P3M1 = 0x78;
  96   1          P1M0 = 0x00;
  97   1          P1M1 = 0x00;
  98   1          // I2C内部上拉
  99   1          P1PU = 0xE0;
 100   1          // Key内部上拉
 101   1          P3PU = 0x78;
 102   1          // RGB 配置推挽输出+高速模式
 103   1          P1M0 |= 0x08;
 104   1          P1SR &= 0xf7;
 105   1      
 106   1          EA = 1;  // 开总中断
 107   1      }
 108          
 109          void delay_ms(u32 ms) {
 110   1          unsigned char data i, j;
 111   1          do {
 112   2              i = 29;
 113   2              j = 183;
 114   2              do {
 115   3                  while (--j)
 116   3                      ;
C51 COMPILER V9.60.7.0   SYS                                                               11/06/2023 23:38:38 PAGE 3   

 117   3              } while (--i);
 118   2          } while (--ms);
 119   1      }
 120          
 121          void delay_us(u32 us) {
 122   1          unsigned char data i;
 123   1      
 124   1          do {
 125   2              _nop_();
 126   2              i = 5;
 127   2              while (--i)
 128   2                  ;
 129   2          } while (--us);
 130   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    363    ----
   CONSTANT SIZE    =     12    ----
   XDATA SIZE       =      1       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
